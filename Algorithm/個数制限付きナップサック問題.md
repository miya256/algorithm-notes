## 概要
$N$ 種類の商品がある。 $i$ 番目の商品の重さが $w_i$ 、価値が $v_i$ であり、 $c_i$ 個まで選ぶことができる。重さの合計が $W$ 以下になるように商品をえらんだときの価値の最大値を求める問題。

### スライド最大値を用いる方法
$i$ 種類目の商品を何個選ぶか決めるときのDPの遷移は、

$$
dp_{i+1}[j]=\max_{0\le k\le c_i}(dp_i[j-kw_i]+kv_i)
$$
である。そのため、 $j$ を $w_i$ で割った余りが $r$ である $j$ について、それぞれ独立に遷移させることができる。ここで、余りが $r$ である列の遷移の例を書く。

$$
\begin{align}
dp_{i+1}[w+r]&=\max(dp_i[w+r], dp_i[r]+v) \\
dp_{i+1}[2w+r]&=\max(dp_i[2w+r], dp_i[w+r]+v, dp_i[r]+2v) \\
dp_{i+1}[3w+r]&=\max(dp_i[3w+r],dp_i[2w+r]+v,dp_i[w+r]+2v,dp_i[r]+3v)
\end{align}
$$
このように、 $\max$ の中身、例えば $dp_i[r]+v$ というのが、遷移によって $2v,3v$ と増えていく。これは、途中でキューの中の数字を変えなければならないということである。このままではスライド最大値が使えないため、式変形をすると、

$$
\begin{align}
dp_{i+1}[w+r]&=\max(dp_i[w+r]-v, dp_i[r])+v \\
dp_{i+1}[2w+r]&=\max(dp_i[2w+r]-2v, dp_i[w+r]-v, dp_i[r])+2v \\
dp_{i+1}[3w+r]&=\max(dp_i[3w+r]-3v,dp_i[2w+r]-2v,dp_i[w+r]-v,dp_i[r])+3v
\end{align}
$$

一般化すると、

$$
dp_{i+1}[tw_i+r]=\max_{t-c_i\le k\le t}(dp_i[kw_i+r]-kv_i)+tv_i
$$

$\max$ の中身が $t$ に依存しないようになり、スライド最大値が使えるようになりました。

### 2冪個のかたまりに分解する方法
$c_i$ 個の商品があるとき、
$$c_i=1+2+4+\dots +\alpha$$

に分解する。分解した後は、それぞれを別の商品とみなして、普通にDPする。

## 計算量
スライド最大値を用いると、
$$O(NW)$$

分解する方法を用いると、 $c_i$ 個の商品は $\log c_i$ 個のグループに分解できるため、$C=\max c_i$ として$$O(NW\log C)$$

## 実装
[実装 : bounded_knapsack.py](https://github.com/miya256/atcoder_lib_py/blob/main/library/dp/bounded_knapsack.py)
## 関連問題